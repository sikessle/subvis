\chapter{Projektverlauf}

In den folgenden Abschnitten wird der Projektverlauf beschrieben und 
dabei auf die erreichten und geplanten Ergebnisse eingegangen, sowie der bisherige Ablauf des Projekts bewertet. Außerdem wird auf die Arbeitsteilung eingegangen.

\section{Aufgabenverteilung}

Für die Entwicklung werden die Themen und Aufgaben unter den Teammitgliedern in drei Arbeitspakete aufgeteilt.

\begin{description}
\item[Architektur, Oberfläche, IDE, Editiermodus] Hierzu gehört die Oberfläche, Bedienung, Architektur inkl. Plugin-System und die Spezifikation einer Entwicklungsumgebung. Des Weiteren die Implementierung des Editiermodus.
\item[Rendering und Darstellung] Berechnung und Darstellung der Kontrollnetze und deren Limesfläche mit OpenGL.
\item[Unterteilungsalgorithmen] Umfasst die Implementierung der ausgewählten Unterteilungsalgorithmen.
\end{description}

\begin{table}[h]
\center
\caption{Aufgabenverteilung unter den Teammitgliedern}
\begin{tabular}{c|c}
Arbeitspaket & Teammitglied\\
\hline
Architektur, Oberfläche, IDE, Editiermodus & Simon Kessler \\
Rendering und Darstellung & Tobias Keh \\
Unterteilungsalgorithmen & Felix Born \\
\end{tabular}
\label{tab:aufgabenverteilung}
\end{table}

\autoref{tab:aufgabenverteilung} zeigt die vorgenommene Aufgabenverteilung des letzten Semesters.

\section{Verlauf der beiden Semester}

Im ersten Semester lag der Schwerpunkt darin, einen Überblick über die theoretischen Grundlagen zu erhalten. 
Hierzu gehören die Unterteilungsalgorithmen und die Darstellung der Kontrollnetze.
Ein weiter wichtiger Punkt war die Evaluierung von Bibliotheken, die bereits Algorithmen und vor allem Datenstrukturen implementieren. 
Als Ergebnis wurde die Datenstruktur Surface\_mesh als am geeignetsten bewertet.

Des Weiteren wurde die Architektur entworfen und in einem UML-Diagramm festgehalten.
Außerdem entstand eine einheitliche Entwicklungsumgebung basierend auf Qt und dem Qt Creator unter Ubuntu.
Diese enthält die nötigen Build-Dateien, Verzeichnisse, Bibliotheken und Git-Konfigurationen.
Jedes Teammitglied besitzt somit eine einheitliche, funktionierende Entwicklungsumgebung.
Zusätzlich wurde eine Dokumentationslösung auf Quelltextebene mittels Doxygen implementiert.

Da für alle Beteiligten der Umgang mit C++ und insbesondere Computergrafik ein neues Themengebiet darstellt, war ein ausführlicher theoretischer Einstieg in das Thema notwendig. 
Hierbei hat sich die Unterstützung durch Herrn Prof. Dr. Georg Umlauf und Pascal Laube als sehr hilfreich erweisen.
In den Projektbesprechungen wurden technische Details geklärt und der theoretische Hintergrund erläutert.
Erst durch Verstehen der Details bezüglich der Unterteilungsalgorithmen, des Renderings und der Anwendbarkeit der Unterteilungsalgorithmen auf verschiedene Kontrollnetze konnten die Tools und Bibliotheken entsprechend evaluiert werden.

Während des Semesters wurden lediglich für sehr kurze Zeiträume und eng eingegrenzte Themengebiete die Aufgaben zwischen den Teammitgliedern verteilt.
Dadurch wurde sichergestellt, dass eine gemeinsame Wissensbasis entsteht, um späteren Missverständnissen vorzubeugen.
Dies hat sich als hilfreich erwiesen und ermöglicht es nun an verschiedenen Teilmodulen der Anwendung parallel zu arbeiten.

Im zweiten Semester wurde das Programm SubVis implementiert. 
Dabei wurden kleinere Änderungen an der Architektur gegenüber der Spezifizierung im ersten Semester vorgenommen.
Zuerst wurde eine GUI und Model-Schicht entwickelt. 
Diese dienten als Plattform, um die weiteren Komponenten zu implementieren.
Danach wurden die einzelnen Algorithmen, Renderingverfahren und der Editiermodus ergänzt.

\begin{table}[]
\vspace*{-35mm}

\center
\caption{Verlauf der Implementierung}

\hspace*{-24mm}
\begin{tabular}{|p{1.6cm}|p{5cm}|p{5cm}|p{5cm}|}
\hline
		  
		  & Architektur, Oberfläche, IDE
      	  & Unterteilungsalgorithmen
      	  & Rendering und Darstellung
      	  \\
    	  
\hline
          
04 / 2015 & Projektsetup, Ordnerstruktur 
          & 
          & -
      	  \\
         
\hline

05 / 2015 & Projektsetup, Ordnerstruktur
		  & 
		  & Einarbeitung OpenGL Rendering
		  \\
		  
\hline

06 / 2015 & Integration und Anpassung
			der Bibliotheken, Kompilierung,
			Codestyle-Tools
		  &
		  & Einarbeitung OpenGL Rendering
		  \\
		  
\hline

07 / 2015 & Integration und Anpassung
			der Bibliotheken, Kompilierung,
			Codestyle-Tools
		  & Zwischenbericht
		  & -
		  \\
		  
\hline

08 / 2015 & Logo, grobe Architektur mit
			Model/View Ebenen,
			NotificationKonzept, Plugin-System,
			Subdivision Plugin, Debugging Konzept
          & Zwischenbericht, Catmull-Clark und Doo-Sabin ohne Boundary,
			Subdivision Base Class für Triangle und Quad Algorithmen,
			Vorbereitung für Loop und Butterfly
          & -
          \\
          
\hline

09 / 2015 & Refactoring, verschiedene Renderer
			als Template-Pattern, primitives
			Mesh-Rendering (solid und Wireframe)
			für Tests, GUI Menüs
		  & Doo-Sabin, Loop, Butterfly und Modified Butterfly fertiggestellt,
		  	Refactoring und Optimierung, Boundary Cases für alle Subdivision Algorithmen,
		  	is\_subdividable Funktion, Dokumentation
		  & Temporäre Zwischenspeicherung des Netzes,
		  	Shader Kompilierung, Shader Programm Linking,
		  	Shader Programm Laden, GLSL Vertex Shader,
		  	GLSL Fragment Shader
		  \\
		  
\hline

10 / 2015 & Mapping Vertex-ID zu Farbwert,
			Multithreading, Rückgängig/Wiederherstellen,
			GUI überarbeitet, GUI Workflow optimiert,
			Splitscreensupport in Model und GUI,
			Synchronisation der Ansichten,
			Plugin-Interface überarbeitet,
			Edit-Modus Vorbereitungen
		  & Code Dokumentation, Fehlerkorrektur Doo Sabin Boundary Case,
		    Fehlerkorrektur Butterfly/ Modified Butterfly Boundary Case,
		    Fehlerkorrektur Loop und Catmull-Clark Boundary Case,
		    Catmull-Clark verallgemeinert für beliebige Netze, Refactoring
		  & Übertragung des Netzes in VBOs,
			Rendern des Netzes aus VBOs
		  \\
		  
\hline

11 / 2015 & Color-Picking Verfahren,
			Performance-Optimierungen
		  & Dokumentation
		  & Färbung des Netzes dynamisch und statisch
		  \\
		  
\hline

12 / 2015 & Editier-Modus, Editier-Constraints
			auf zwei Ebenen basierend auf der
			Vertex-Normalen, Support für beide
			Netze: Speichern/Laden/Triangulation/Screenshots,
			Dokumentation
		  & Code Dokumentation, Finaler Abschlussbericht
		  & Vorbereitung Beleuchtung und Shading Modi in GLSL
		    Fragment Shader, Entscheidung zur Umstellung auf
		    vereinfachtes Rendering, da keine entscheidenden
		    Performancevorteile
		  \\   

\hline

01 / 2016 & Bugfixes, Refactoring
		  & Code Dokumentation, Finaler Abschlussbericht
		  & Vereinfachtes Rendering mit Indexierung,
			Färbung, Shading Modi, Beleuchtung,
			Optimierung des Renderings,
			Dokumentation und Abschlussbericht
		  \\    
		  
\hline

02 / 2016 &
		  &
		  & Rendering der Limesfläche von Catmull-Clark und Doo-Sabin
		    als Bezier Fläche (falsch),
		    Interpolierender Renderer,
		    Duplizierung des Netzes für mehrfache
		    Anwendung der Unterteilungsalgorithmen,
		    Dokumentation und Abschlussbericht
		  \\  
		  
\hline   
		               
\end{tabular}
\label{tab:verlauf}
\end{table}

\autoref{tab:verlauf} zeigt den Verlauf der Implementierung.

In Anlehnung an agile Entwicklungsmodelle wurden zweiwöchige Meetings mit den Betreuern Prof. Dr. Georg Umlauf und Pascal Laube durchgeführt. 
Dort wurde auch der aktuelle Stand der Software präsentiert oder Fragen geklärt.
So konnte frühzeitig auf Änderungs- und Funktionswünsche eingegangen werden.

Schlussendlich kann das Projekt als erfolgreich bezeichnet werden, da beinahe alle vorgesehenen Funktionen und darüber hinaus noch weitere implementiert wurden.
Lediglich das Rendering der Limesflächen der Unterteilungsalgorithmen Catmull-Clark und Doo-Sabin fehlt in der aktuellen Version, wird aber in der nächsten Version ergänzt.
Die Entscheidung für die Implementierung eines manuellen Renderings ist für diesen Verzug verantwortlich.
Der erhoffte Performance-Gewinn, im Vergleich zum vereinfachten Rendering, ist nicht eingetreten und ist auch schlussendlich nicht notwendig.
Der dadurch entstandene Zeitverlust war bis Projektende jedoch nicht mehr vollständig aufzuholen.
Die Entscheidung für ein manuelles Rendering hat allerdings zu einem großen Erkenntnisgewinn geführt, da in diesem Gebiet noch keine Kenntnisse vorlagen.
Basierend hierauf konnte das vereinfachte Rendering in sehr kurzer Zeit umgesetzt werden.

Zusammenfassend war dies für alle beteiligten Studenten ein überaus lehrreiches Projekt mit einigen neuen Programmiersprachen und Anwendungsdomänen.
