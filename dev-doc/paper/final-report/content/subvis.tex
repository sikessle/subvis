\chapter{SubVis}

Nachfolgend wird das Programm \emph{SubVis} spezifiziert und dessen Architektur vorgestellt.
Außerdem wird auf die konkrete Implementierung, Tools, Bibliotheken und Dokumentation eingegangen.

\section{Anforderungen}

\begin{itemize}
 \item Architektur
 \begin{itemize}
 	\item Erweiterbarkeit durch andere Algorithmen und Visualisierungen mittels Plugins.
 	\item Plugins können eigene GUI-Elemente in dafür vorgesehenen Bereichen zeichnen.
 	  \item Anwendung von verschiedenen Algorithmen auf den jeweiligen Polygonnetzen
 	  \item Rückgängig/Wiederherstellen von Operationen
 \end{itemize}
 \item GUI
  \begin{itemize}
 	\item Darstellung des Kontrollnetzes
 	\item Darstellung der Limesfläche
 	\item Rotation des Objektes
 	\item Translation des Objektes
 	\item Skalierung des Objektes
 	\item Beleuchtung der Oberfläche des Netzes, um Glattheit bewerten zu können
 	\item Edit-Modus: Verschieben eines Punktes anhand seiner Flächennormalen
 	\item Abbrechen von langlaufenden Unterteilungsschritten
    \item Statistik des Polygonnetzes anzeigen
    \item Splitscreen zur Darstellung von zwei Polygonnetzen
 \end{itemize}
 \item Dateiformate / IO
 \begin{itemize}
 	\item OFF-Format und NOFF (mit Farben/Normalen)
 	\item Laden und Speichern von Polygonnetzen
 \end{itemize}
 \item Unterteilungsalgorithmen
 \begin{itemize}
 	\item Catmull-Clark
 	\item Loop
 	\item Doo-Sabin
 	\item Butterfly
 	\item Modified Butterfly
 \end{itemize}
 \item Funktionen
 \begin{itemize}
  \item Variable Anzahl von Unterteilungsschritten
  \item Beleuchtungsmodus wählbar

 \end{itemize}
\end{itemize}

\section{Tools und Bibliotheken}

\emph{SubVis} greift auf die Bibliotheken Qt, libQGLViewer, OpenGL Mathematics, astyle, Surface\_mesh, OpenGL und Doxygen zurück.
Die verwendeten Versionen sind in \autoref{tab:versionen} ersichtlich.

\begin{table}[h]
\center
\caption{Versionen der Bibliotheken}
\label{tab:versionen}
\begin{tabular}{c|c}
Bibliothek & Version\\
\hline
Qt & 5.4.1\\
libQGLViewer & 2.6.1\\
Surface\_mesh & 1.0\\
OpenGL & 10.1.3-0ubuntu0.4\footnote{Ubuntu Paket mesa-common-dev}\\
Doxygen & 1.8.6\\
GLM & libglm-dev 0.9.5.1-1\\
Astyle & 2.03\\
\end{tabular}
\end{table}

\section{Entwicklungsprozess}

Um eine gemeinsame Entwicklungsumgebung zu schaffen, wurden gewisse Bibliotheken, Tools und Plattformen spezifiziert.
Dies betrifft einerseits die Bibliotheken und Tools aus \autoref{tab:versionen}.
Andererseits auch das Betriebssystem, Versionsverwaltung, IDE und Programmiersprachenstandard.

Als Betriebssystem wird Ubuntu 14.04 LTS verwendet. 
Zum Projektabschluss wird jedoch eine plattformunabhängige Anwendung angestrebt.
Die Sprachfeatures von C++ sollen maximal dem C++11 Standard entsprechen.
Als Versionsverwaltung wird Git in Verbindung mit dem Git-Server des IOS an der HTWG eingesetzt. 

Die Entwicklung findet auf dem \emph{develop}-Branch und eventuellen Feature-Branches statt.
Dabei sollte ein Branch pro Feature erstellt werden und erst dann in den develop-Branch gemergt werden, wenn das Feature funktioniert.
Als IDE wird der vorgestellte Qt Creator verwendet.

Zur Formatierung des Quellcodes wird astyle verwendet. 
Die Options-Datei style.astylerc definiert für das Projekt die Formatierungsregeln. 

Als Style Guide für den Programmierstil wird der Google C++ Style Guide verwendet \cite{GsgC++}.
Abweichungen sind jedoch in begründeten Fällen erlaubt und werden dokumentiert.

Das Projekt teilt sich in zwei Verzeichnisse auf: \emph{SubVis} und \emph{dev-doc}.
\emph{SubVis} enthält die gleichlautende Anwendung als Qt-Projekt und unterteilt sich noch in die Ordner \emph{app}, \emph{lib} und \emph{objs}.
\emph{app} enthält die Anwendungsteile die selbst entwickelt werden,
\emph{lib} die Drittherstellerbibliotheken und \emph{objs} 3D-Modelle zum Testen.
\emph{dev-doc} dient der weiterführenden Dokumentation.
Das Verzeichnis enthält z. B. Diagramme, diesen Bericht und andere hilfreiche Dokumente zur Entwicklung.

\section{Grafische Oberfläche}

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{content/media/subvis_mesh.png}
  \caption{Kontrollnetz in SubVis}
  \label{fig:subvis_mesh}
\end{figure}

Die grafische Oberfläche bietet eine aufgeräumte Ansicht der wichtigsten Elemente (siehe \autoref{fig:subvis_mesh}). 
Im oberen Bereich findet sich die Menüleiste mit Dateioperatoren, Editierwerkzeugen und Optionen zur Steuerung der Ansicht.
Darunter befindet sich eine Toolbar, welche häufig verwendete Aktionen enthält.
Am unteren Ende des Fensters ist eine Statusleiste integriert, welche Informationen über das Polygonnetz anzeigt (Anzahl an Knoten etc.).
Der Hauptbereich der Anwendung ist die Darstellung von zwei Viewern, welche separat bedient werden können und verschiedene Zustände der Polygonnetze darstellen können.
Diese unterstützen Rotation, Zoom und Translation.
Über die Tabs darüber kann zwischen der generischen Polygonnetzansicht und Plugin-spezifischen Ansichten umgeschaltet werden.
Geladene Plugins werden auf der rechten Seite in Form von Tabs angezeigt.
Diese besitzen eine jeweils individuelle GUI.

Die Anwendung bietet eine Rückgängig/Wiederherstellen Funktion in Form von zwei Pfeilen. Durch diese können Modifikationen an den Polygonnetzen rückgängig gemacht werden.
Manchmal ist es von Vorteil, wenn die beiden getrennten Viewer sich synchronisieren.
Dies kann über die Funktion \enquote{Synchronize Views} erreicht werden. 
Nach der Aktivierung bewegen sich die Kameras der beiden Viewer absolut synchron.
Eine Art \enquote{ablenkungsfreier Modus} lässt sich erreichen, in dem der zweite, rechte Viewer ausgeblendet wird. 
Zusätzlich kann die rechte Tableiste der Plugins ausgeblendet oder verkleinert werden.

Alle Menü- und Toolbar-Elemente lassen sich auch über Tastenkürzel erreichen.

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{content/media/subvis_edit.png}
  \caption{1) Selektion eines Vertex 2) Translation 3) Resultierendes Polygonnetz}
  \label{fig:subvis_edit}
\end{figure}

Durch Aktiveren des Editiermodus (siehe \autoref{fig:subvis_edit}) wird in den ablenkungsfreien Modus geschaltet.
Nach Doppelklick auf einen Vertex oder dessen unmittelbare Umgebung wird dieser selektiert, vergrößert in rot dargestellt und dessen Normale in weiß eingezeichnet (siehe Schritt 1 von \autoref{fig:subvis_edit}).
Während der Vertex mittels STRG+linke Maustaste im Raum bewegt wird, wird zusätzlich eine rote Linie zwischen der Ursprungsposition und der neuen Position angezeigt (siehe Schritt 2 von \autoref{fig:subvis_edit}).
Dabei bewegt sich der Vertex lediglich auf der Ebene, die durch die Normale des Vertex definiert wird.
Damit eine beliebige Positionierung im Raum möglich ist, kann zwischen der Ebene der Normale und einer Ebene, die orthogonal zur dieser steht mit der Taste S umgeschaltet werden.
Durch erneutes Doppelklicken (an einer beliebigen Stelle) wird der Editiervorgang beendet und das veränderte Polygonnetz dargestellt (siehe Schritt 3 von \autoref{fig:subvis_edit}).


\section{Implementierung}

In diesem Kapitel wird auf die konkrete Architektur, Implementierung und detaillierte Entwicklungsentscheidungen eingegangen.

\subsection{Architektur}

Linken der Bibliotheken, Signal Slots

Es wurde bisher die grundlegende Grob-Architektur festgelegt, welche definiert, welche Komponenten bestehen und wie diese miteinander kommunizieren.
In \autoref{fig:subvis_architektur} ist diese als UML-Komponentendiagramm dargestellt.

Grundsätzlich wird auf eine MVC Architektur gesetzt.
Die Model-Komponente soll die Datenstruktur mit dem Polygonnetz beinhalten und Import bzw. Persistenzoperationen anbieten.
Das Delegieren der Ereignisse aus der View-Komponente wird von der Controller-Komponente übernommen. 
Dort sollen auch die entsprechende Signale und Slots definiert werden.
Insbesondere die Editieroperationen werden an die MeshEdit-Komponente übergeben, welche dann die MeshData-Komponente ansteuert.
In der View-Komponente wird die GUI erstellt und gerendert. 
Deren Schnittstelle muss Operationen zum Erweitern der GUI und zum Beeinflussen des Renderings des Hauptfensters bereitstellen.
Auf diese Schnittstelle greifen dann die Plugins zu, die entsprechend eigene GUI-Elemente zeichnen und Plugin-spezifische Renderingmodi anbieten.

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{content/media/subvis_architektur.png}
  \caption{Geplante Architektur von SubVis}
  \label{fig:subvis_architektur}
\end{figure}

\subsection{Speicherverwaltung}


\subsection{Model}
Undo/

\subsection{View}

Sync etc.

\subsection{Plugins}


\section{Erstellung eines Plugins}

\section{Dokumentation}

Die Dokumentation besteht aus diesem Bericht sowie der finalen schriftlichen Ausarbeitung am Ende des 2. Semesters.
Diese Ausarbeitung soll die theoretischen Hintergründe erklären, sowie auf die Entwicklungsprozesse inkl. Vergleich und Entscheidungen für spezifische Technologien eingehen.
Ziel ist es, dem Leser eine Top-Down-Ansicht auf das Projekt zu verschaffen.
Es wird bewusst auf eine detaillierte Quellcodedokumentation in der Ausarbeitung verzichtet, um die Dokumentation nahe am Quellcode und aktuell zu halten.

Durch Quellcodedokumentierung sollen Entwickler befähigt werden schnell in das Projekt einsteigen zu können und das Programm weiter zu entwickeln bzw. durch Plugins zu erweitern.
Insbesondere bei den Plugins soll ein kurzes Tutorial erstellt werden, welches an die Plugin-Entwicklung heranführt. 
Des Weiteren soll ein kleines, gut dokumentiertes Plugin entstehen, um den prinzipiellen Aufbau zu veranschaulichen.
Wenn zu viel dokumentiert wird, veraltet diese schneller.
Deswegen soll \emph{sinnvoll} und \emph{angemessen} dokumentiert werden.
Dies bedeutet öffentliche APIs, wenn notwendig, detailliert und ausführlich zu dokumentieren und selbsterklärende Funktionen etc. nicht unnötig zu dokumentieren.
Grundsätzlich soll der Quellcode selbst schon als Dokumentation dienen können.
Zusätzlich finden sich beim Quellcode README-Dateien, die genaue Details über die verwendeten Funktionen, Build-Anleitungen und die Projektstruktur erläutern.

\section{Buildprozess}

\section{Installation}

\section{Benutzerhandbuch}
































